<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coding on BRIdGE&#39;s blog</title>
    <link>https://blog.queenbridge.tech/tags/coding/</link>
    <description>Recent content in Coding on BRIdGE&#39;s blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 30 Oct 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://blog.queenbridge.tech/tags/coding/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MIT 6.5840(1) - Introduction</title>
      <link>https://blog.queenbridge.tech/posts/2024_fall/mit-6.58401/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.queenbridge.tech/posts/2024_fall/mit-6.58401/</guid>
      <description>&lt;p&gt;重生之我要学习分布式系列第一篇。&lt;/p&gt;&#xA;&lt;p&gt;课程主页：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://pdos.csail.mit.edu/6.824/schedule.html&#34;&gt;6.5840 Schedule: Spring 2024&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;明星课程MIT 6.5840: Distributed Systems，原名6.824，在2024年一共布置了5个lab。这几个lab循序渐进，从古法分布式MapReduce搓起，然后手搓raft，并最终造出类似TiKV的分布式数据库，整个过程做下来真有种开局一根针手搓Windows的爽感。&lt;/p&gt;&#xA;&lt;h1 id=&#34;如何防治劲椎病&#34;&gt;如何防治劲椎病&lt;/h1&gt;&#xA;&lt;p&gt;就像某国产3A大作的九九八十一难的第一难是解压游戏，本课程的第一难是让人憋出劲椎病的文档网页。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;&#xD;&#xA;        /posts/2024_fall/assets/1730276090038-6c05e18c-4302-47f8-be88-ac49b3f71235.png&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;由于文档弹道偏左，考虑在控制台里把它水平居中。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; body &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.body;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;body.style.maxWidth &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;800px&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;body.style.marginLeft &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;auto&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;body.style.marginRight &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;auto&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; elements &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; body.getElementsByTagName(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; i &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt; elements.length; i&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    elements[i].style.maxWidth &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;100%&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    elements[i].style.boxSizing &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;border-box&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;lab内容简单介绍&#34;&gt;lab内容简单介绍&lt;/h1&gt;&#xA;&lt;p&gt;lab1是比较独立的开胃小菜，要实现一个Google曾经使用的MapReduce框架。&lt;/p&gt;&#xA;&lt;p&gt;lab2实现一个简单的单体KV服务器，要求在网络不稳定的情况下也能保证服务不出错。&lt;/p&gt;&#xA;&lt;p&gt;lab3则是实现Raft协议。&lt;/p&gt;&#xA;&lt;p&gt;lab4要基于lab3实现的Raft协议，构建一个KV服务器集群，也就是在lab2的基础上用Raft协议保证Fault-tolerant。&lt;/p&gt;&#xA;&lt;p&gt;lab5则要在lab4的基础上，把数据库的数据分为几个分片（shard）来减轻单个服务器负担，需要实现他们的数据迁移。&lt;/p&gt;&#xA;&lt;p&gt;个人认为最难实现的两个lab显然是lab3和lab5。lab3需要对Raft的原始论文仔细研读，lab5则需要一开始就设计好整个架构如何实现，辅以网上搜索相关的实现思路才好开始上手。&lt;/p&gt;&#xA;&lt;h1 id=&#34;debug小技巧&#34;&gt;Debug小技巧&lt;/h1&gt;&#xA;&lt;p&gt;个人认为实现这些lab最有挑战性的地方不是在设计或者编写上，而是debug上。因为传统的打断点debug方法是对一个单体应用操作，而本次lab需要面对的是一个集群系统，打断点的方法就很难操作，所以主要还是靠print大法。那么设计一个好的打印函数非常有必要，例如可以把打印函数抽象出来。例如lab5我用了这样一个函数对println包装&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;SSPrintf&lt;/span&gt;(format &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, a &lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt;{}) (n &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, err &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; SDebug {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;log.&lt;span style=&#34;color:#50fa7b&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[server %d]&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt;format, &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;([]&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt;{}{kv.gid}, a&lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;)&lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;kv.gid是标识ShardKV的相关信息之一，实践上还可以塞入更多的基本信息，当然这可能要考虑获取这些信息会不会造成读写上的条件竞争的问题。&lt;/p&gt;&#xA;&lt;p&gt;本次实验我只用了SDebug来判断是否打印日志，但实际上可以设计一个类似level的东西，来方便区分重要日志和不那么重要的日志。&lt;/p&gt;&#xA;&lt;p&gt;在需要分析Bug日志的时候，可以借助Linux的tee命令让日志同时输出到stdout和文件里。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;test&lt;/span&gt; -race -run TestConcurrent3_5B | tee bug.txt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在需要输出日志的地方可以多加几个条件判断，确认是bug可能发生的那种条件，这样可以减少大量无意义的日志。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MIT 6.5840(2) - Lab1 MapReduce</title>
      <link>https://blog.queenbridge.tech/posts/2024_fall/mit-6.58402/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.queenbridge.tech/posts/2024_fall/mit-6.58402/</guid>
      <description>&lt;h1 id=&#34;理论&#34;&gt;理论&lt;/h1&gt;&#xA;&lt;p&gt;MapReduce主要用来解决大规模数据处理的问题，它能够将一个计算任务分解为许多小任务，这些小任务可以在多台机器上并行执行，从而大大提高处理速度和效率。&lt;/p&gt;&#xA;&lt;p&gt;它的核心思想参考Google论文中的图片&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;&#xD;&#xA;        /posts/2024_fall/assets/1720323199815-9184d63b-4736-412e-bc32-1487718c2c04.png&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Master程序是主要的程序，它会将文件（N个）分配个worker，所有worker是对等的。worker将会首先执行Map命令，接受一些文件，然后输出为键值对并写入R个（用户可以自定义R的值）中间文件（图中的Intermediate files）。&lt;strong&gt;当所有Map任务完成后&lt;/strong&gt;，Master会给worker分配Reduce任务，对中间文件进行处理，然后生成最终的结果文件。&lt;/p&gt;&#xA;&lt;p&gt;其中，Map函数和Reduce函数可以以插件的形式提供给系统。&lt;/p&gt;&#xA;&lt;p&gt;例如，在Words Count场景下（统计若干文件里每个相同单词的数量）：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;map(String key, String value):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    // key: document name&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    // value: document contents&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    for each word w in value:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        EmitIntermediate(w, &amp;#34;1&amp;#34;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;reduce(String key, Iterator values):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    // key: a word&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    // values: a list of counts&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    int result = 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    for each v in values:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result += ParseInt(v);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Emit(AsString(result));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个例子中，map函数将生成一系列key为word，value为&amp;quot;1&amp;quot;的中间文件，然后reduce将同一个key聚合，统计value的数量。&lt;/p&gt;&#xA;&lt;p&gt;这样我们就实现了数据集的分布式处理。&lt;/p&gt;&#xA;&lt;h1 id=&#34;代码&#34;&gt;代码&lt;/h1&gt;&#xA;&lt;p&gt;系统的启动流程如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>MIT 6.5840(3) - Lab3 Raft</title>
      <link>https://blog.queenbridge.tech/posts/2024_fall/mit-6.58403/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.queenbridge.tech/posts/2024_fall/mit-6.58403/</guid>
      <description>&lt;p&gt;由于Lab2是一个KV数据库，和Lab3、Lab4比较相关，所以之后的文章会把他们放在一起。这篇文章先介绍Lab3。&lt;/p&gt;&#xA;&lt;h1 id=&#34;raft算法概览资料&#34;&gt;Raft算法概览资料&lt;/h1&gt;&#xA;&lt;p&gt;可以去这个网站可视化地理解Raft算法&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://thesecretlivesofdata.com/raft/#home&#34;&gt;Raft (thesecretlivesofdata.com)&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;算法实现的所有细节在raft-extended论文中都有清晰的阐述，这里不再赘述。重点关注figure 2的实现逻辑&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf&#34;&gt;pdos.csail.mit.edu/6.824/papers/raft-extended.pdf&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;3a-leader-election&#34;&gt;3A: Leader Election&lt;/h1&gt;&#xA;&lt;p&gt;为了实现Leader Election，事实上我们就要实现Raft中最核心的两个timing了。我把ElectionTimeout和broadcastTime分别用electionTickerHandler和broadcastTickerHandler封装，他们用Ticker来控制（尽管课程建议不要用Ticker，但其实也不难实现）&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;Ticker&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;killed&lt;/span&gt;() &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;rf.electionTimer.C:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;electionTickerHandler&lt;/span&gt;()&lt;span style=&#34;color:#6272a4&#34;&gt;// 这个函数会reset timer，下同&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&#x9;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;rf.broadcastTimer.C:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;broadcastTickerHandler&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// reset timer&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;resetElectionTimeout&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#50fa7b&#34;&gt;resetTimer&lt;/span&gt;(rf.electionTimer, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getElectionTimeout&lt;/span&gt;())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;resetBroadcastTimeout&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#50fa7b&#34;&gt;resetTimer&lt;/span&gt;(rf.broadcastTimer, time.&lt;span style=&#34;color:#50fa7b&#34;&gt;Duration&lt;/span&gt;(broadcastTimeout)&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;time.Millisecond)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;resetTimer&lt;/span&gt;(timer &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;time.Timer, d time.Duration) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !timer.&lt;span style=&#34;color:#50fa7b&#34;&gt;Stop&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;timer.C:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;default&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;timer.&lt;span style=&#34;color:#50fa7b&#34;&gt;Reset&lt;/span&gt;(d)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 初始化：&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;rf.electionTimer = time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTimer&lt;/span&gt;(rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getElectionTimeout&lt;/span&gt;())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rf.broadcastTimer = time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTimer&lt;/span&gt;(time.&lt;span style=&#34;color:#50fa7b&#34;&gt;Duration&lt;/span&gt;(broadcastTimeout) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; time.Millisecond)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;electionTickerHandler根据当前state的状态决定是否要发起竞选&lt;/p&gt;</description>
    </item>
    <item>
      <title>MIT 6.5840(4) - Lab2 &amp; Lab4</title>
      <link>https://blog.queenbridge.tech/posts/2024_fall/mit-6.58404/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.queenbridge.tech/posts/2024_fall/mit-6.58404/</guid>
      <description>&lt;h1 id=&#34;lab2-keyvalue-server&#34;&gt;Lab2 Key/Value Server&lt;/h1&gt;&#xA;&lt;p&gt;lab2要求实现一个线性一致的KV数据库，可能会存在不稳定的网络（比如高延迟、丢包等情况），但是server不会crash。&lt;/p&gt;&#xA;&lt;p&gt;难点在于client由于超时重传（类似于TCP），可能会发送一个请求多次，server接收到的这些重复请求也不一定是连续的。此时就需要server维护一个hashMap用于记录请求ID以及对应的第一次成功的返回结果。&#xA;hashSet显然需要及时清理。我采用的方案是client在确认发包成功后，继续发送携带请求ID的ResolveRPC直到成功，server通过ResovleRPC把hashMap中的请求ID删除。删除操作是幂等的，不需要保证线性一致。&#xA;例如，一个完整的PUT请求如下：&lt;/p&gt;&#xA;&lt;p&gt;server维护done = make(map[int64]string)&lt;/p&gt;&#xA;&lt;p&gt;● client发送PUT(x,1)，ID=1&lt;/p&gt;&#xA;&lt;p&gt;● server判断ID是否存在于done。如果存在，返回里面的值；否则处理并把结果存在done里&lt;/p&gt;&#xA;&lt;p&gt;● client收到之后发送Resolve(1)&lt;/p&gt;&#xA;&lt;p&gt;● server执行delete(done, 1)&lt;/p&gt;&#xA;&lt;p&gt;一次上述的操作是原子性的。&lt;/p&gt;&#xA;&lt;h1 id=&#34;lab4-fault-tolerant-kvserver&#34;&gt;Lab4 Fault-tolerant KVServer&lt;/h1&gt;&#xA;&lt;p&gt;基于RAFT协议实现一个Fault-tolerant KVServer&lt;/p&gt;&#xA;&lt;h2 id=&#34;client实现&#34;&gt;Client实现&lt;/h2&gt;&#xA;&lt;p&gt;所有的读写请求都必须直接从client发送给leader server。有两种情况client不知道leader是谁：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一次发送请求&lt;/li&gt;&#xA;&lt;li&gt;server易主/crash，返回报错&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;此时client就需要不断重新尝试另一个server，直到请求被成功接收。注意到不同的命令有相同的发送方式，可以抽象出一层来专门用于发送RPC，我这里使用了策略模式。&lt;/p&gt;&#xA;&lt;h2 id=&#34;server实现&#34;&gt;Server实现&lt;/h2&gt;&#xA;&lt;h3 id=&#34;如何返回rpc结果&#34;&gt;如何返回RPC结果&lt;/h3&gt;&#xA;&lt;p&gt;对于RPC接受的一个Op，leader需要将它通过Raft的Start接口达成共识。对于写请求（GET），client只需要知道它成功就行；对于读请求（PUT/APPEND），client还需要知道结果。&lt;/p&gt;&#xA;&lt;p&gt;我们用一个专门的协程applier循环读取Raft commit上来的Op。如果是读请求，不做处理；如果是写请求，则更新KVmap。这样每一个Op都对应着一个独立的commandIndex，定义一个这样的map：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;resultChMap &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; opResult&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;RPC协程与applier协程通过这个map里的管道通信，以返回RPC结果。&lt;/p&gt;&#xA;&lt;p&gt;要注意RPC在返回结果后需要销毁对应的通道。&lt;/p&gt;&#xA;&lt;h3 id=&#34;幂等性设计&#34;&gt;幂等性设计&lt;/h3&gt;&#xA;&lt;h4 id=&#34;raft层commitindex幂等&#34;&gt;raft层commitIndex幂等&lt;/h4&gt;&#xA;&lt;p&gt;raft有可能提交log过时的commitIndex，因此要注意在真正apply的时候添加如下判断&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; msg.CommandIndex &amp;gt; kv.lastApplied&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但这样可能会造成过时请求得不到channel的信息而发生阻塞，所以还需要在RPC处添加timeout。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ticker &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTicker&lt;/span&gt;(time.&lt;span style=&#34;color:#50fa7b&#34;&gt;Duration&lt;/span&gt;(CHANNEL_TIMEOUT) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; time.Millisecond)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; ticker.&lt;span style=&#34;color:#50fa7b&#34;&gt;Stop&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; opResult &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;ch:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; opResult.err &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        reply.Err = &lt;span style=&#34;color:#50fa7b&#34;&gt;Err&lt;/span&gt;(opResult.err)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;ticker.C:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    reply.Err = NOTALEADER&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;client请求幂等&#34;&gt;client请求幂等&lt;/h4&gt;&#xA;&lt;p&gt;由于网络故障等原因，server接收到的命令可能是重复的，并且client只认最新结果（这和TCP超时重传有所差异）。对于读请求，并不会使得KVmap状态发生改变；但是对于写请求，就必须保证它的幂等性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MIT 6.5840(5) - Lab5 Sharded KeyValue Service</title>
      <link>https://blog.queenbridge.tech/posts/2024_fall/mit-6.58405/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.queenbridge.tech/posts/2024_fall/mit-6.58405/</guid>
      <description>&lt;h2 id=&#34;font-stylecolorrgb0-0-0架构总览font&#34;&gt;&lt;!-- raw HTML omitted --&gt;架构总览&lt;!-- raw HTML omitted --&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Lab5在KVRaft的基础上实现了数据的分布式存储，把全量数据分成一个个&amp;quot;Shard&amp;quot;，分别存储在不同的Group里，每个Group是一群Raft集群，这些Group里的服务器可以通过外部API实时调整他们的加入、退出。&lt;/p&gt;&#xA;&lt;p&gt;下面这张图描述了ShardKV的架构&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;&#xD;&#xA;        /posts/2024_fall/assets/1730270544444-d1c43a0e-510d-4208-ac45-4ac8184a4497-1730303201535-3-1730303541114-3.png&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;一些补充：&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个Group之间唯一的通信是Shard Migration，和Raft无关，而一个Group的内部几个Server形成一个Raft集群&lt;/li&gt;&#xA;&lt;li&gt;Group N里的KVServer 1是当前Group的raft leader，其余是follower。当Client请求KVServer的时候，会像KVRaft那样遍历这些KVServer，直到找到Leader&lt;/li&gt;&#xA;&lt;li&gt;Config的定义如下：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Config &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Num    &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;              &lt;span style=&#34;color:#6272a4&#34;&gt;// config number&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    Shards [NShards]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;     &lt;span style=&#34;color:#6272a4&#34;&gt;// shardId -&amp;gt; gid&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    Groups &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;][]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// gid -&amp;gt; servers[]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&amp;ldquo;Shard&amp;rdquo;，是由Key唯一确定的，课程代码里给的转换方式是：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;key2shard&lt;/span&gt;(key &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(key) &amp;gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;shard = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;int&lt;/span&gt;(key[&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;shard &lt;span style=&#34;color:#ff79c6&#34;&gt;%=&lt;/span&gt; shardctrler.NShards&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; shard&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;5a-shardctrler&#34;&gt;5A shardctrler&lt;/h2&gt;&#xA;&lt;p&gt;需要实现这几个接口：Join/Leave/Move/Query。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
