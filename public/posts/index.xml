<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on BRIdGE&#39;s blog</title>
    <link>https://blog.kingbridge.one/posts/</link>
    <description>Recent content in Posts on BRIdGE&#39;s blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 04 Nov 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://blog.kingbridge.one/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>在校园网通过PVE&#43;OpenWRT NAT接入有线网</title>
      <link>https://blog.kingbridge.one/posts/2024_fall/pveandnat/</link>
      <pubDate>Mon, 04 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.kingbridge.one/posts/2024_fall/pveandnat/</guid>
      <description>&lt;p&gt;注：本篇主要讲述网络配置，PVE装机等细节懒得写了（&lt;/p&gt;&#xA;&lt;p&gt;废话：时隔一万年后一个叫bridge的fw终于想起了他的博客，决定更新。原来用的博客是xlog，但是发现主页文章卡片飘忽不定。github上有&lt;a href=&#34;https://github.com/Crossbell-Box/xLog/issues/2173&#34;&gt;很多类似的issues&lt;/a&gt;(文章末尾有反转)。正值mac-mini发售之际，周围朋友对小主机的热情似乎提高了起来。bridge看着脚下吃灰的小主机，决定用它配一个PVE用来跑博客。&lt;/p&gt;&#xA;&lt;p&gt;但是接入学校的有线网有个问题：接入的交换机有一个IP-MAC表，需要申请登记，否则不在表里会被拦截。所以Plan A：所有虚拟机全部桥接，每开一个虚拟机都找管理员登记一遍。为了防止管理员说&amp;quot;how old are you&amp;quot;，就有了Plan B。&lt;/p&gt;&#xA;&lt;p&gt;于是为了这个博客，bridge包了这样一盘饺子：&lt;/p&gt;&#xA;&lt;h1 id=&#34;网络拓扑图&#34;&gt;网络拓扑图&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;&#xD;&#xA;        /posts/2024_fall/assets/1730736611574-682f5fe3-0e26-47e4-827f-df0a709e240d.jpeg&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;OpenWRT作为软路由，用SNAT给PVE里的虚拟机开了一个内网，这样在出网的时候都用的是OpenWRT的IP-MAC。内网设备通过PVE的vmbr1桥接网络连在一起，而vmbr0连接了OpenWRT和物理网卡。&lt;/p&gt;&#xA;&lt;p&gt;怎么从外部管理内部虚拟机？这里我在OpenWRT上装了一个tailscale，开启子网转发。&lt;/p&gt;&#xA;&lt;p&gt;博客怎么弄到公网？我使用了cloudflare的TUN，它相当于一个反向代理，可以直接把&lt;code&gt;blog.queenbridge.tech&lt;/code&gt;转发到探针（cloudflared container）上，然后探针向内网请求再发给公网。&lt;/p&gt;&#xA;&lt;h1 id=&#34;搭建过程一些坑&#34;&gt;搭建过程&amp;amp;&amp;amp;一些坑&lt;/h1&gt;&#xA;&lt;h2 id=&#34;pve&#34;&gt;PVE&lt;/h2&gt;&#xA;&lt;p&gt;最原始的情况下，我们只有一个PVE，如果按照最终的拓扑我的laptop根本没办法连上管理端口。所以在OpenWRT配置完成之前有两种办法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;把laptop和PVE都连到交换机上，PVE和laptop的有线口网关设成校园网的网关&lt;/li&gt;&#xA;&lt;li&gt;干脆把直接laptop和PVE用一根网线连起来&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;首先给PVE添加两个桥接网络，vmbr0桥接到物理有线网卡enp1s0上用于通过交换机连校园网，vmbr1用作内网广播域。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;&#xD;&#xA;        /posts/2024_fall/assets/1730738897489-a0654c93-faa4-44fe-b458-5ac519891d94.png&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;登录PVE，最终/etc/network/interfaces的配置如下&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;auto lo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;iface lo inet loopback&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;iface enp1s0 inet manual&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;iface wlp2s0 inet manual&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;auto vmbr0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;iface vmbr0 inet static&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        address &lt;span style=&#34;color:#bd93f9&#34;&gt;10&lt;/span&gt;.X.X.X/&lt;span style=&#34;color:#bd93f9&#34;&gt;24&lt;/span&gt;  &lt;span style=&#34;color:#6272a4&#34;&gt;# 校园网IP&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;bridge-ports&lt;/span&gt; enp1s0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;bridge-stp&lt;/span&gt; off&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;bridge-fd&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;auto vmbr1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;iface vmbr1 inet static&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        address &lt;span style=&#34;color:#bd93f9&#34;&gt;192.168&lt;/span&gt;.233.&lt;span style=&#34;color:#bd93f9&#34;&gt;10&lt;/span&gt;/&lt;span style=&#34;color:#bd93f9&#34;&gt;24&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        gateway &lt;span style=&#34;color:#bd93f9&#34;&gt;192.168&lt;/span&gt;.233.1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        bridge_ports none&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        bridge_stp off&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        bridge_fd &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;source /etc/network/interfaces.d/*&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;立即使用配置：&lt;/p&gt;</description>
    </item>
    <item>
      <title>MIT 6.5840(1) - Introduction</title>
      <link>https://blog.kingbridge.one/posts/2024_fall/mit-6.58401/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.kingbridge.one/posts/2024_fall/mit-6.58401/</guid>
      <description>&lt;p&gt;重生之我要学习分布式系列第一篇。&lt;/p&gt;&#xA;&lt;p&gt;课程主页：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://pdos.csail.mit.edu/6.824/schedule.html&#34;&gt;6.5840 Schedule: Spring 2024&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;明星课程MIT 6.5840: Distributed Systems，原名6.824，在2024年一共布置了5个lab。这几个lab循序渐进，从古法分布式MapReduce搓起，然后手搓raft，并最终造出类似TiKV的分布式数据库，整个过程做下来真有种开局一根针手搓Windows的爽感。&lt;/p&gt;&#xA;&lt;h1 id=&#34;如何防治劲椎病&#34;&gt;如何防治劲椎病&lt;/h1&gt;&#xA;&lt;p&gt;就像某国产3A大作的九九八十一难的第一难是解压游戏，本课程的第一难是让人憋出劲椎病的文档网页。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;&#xD;&#xA;        /posts/2024_fall/assets/1730276090038-6c05e18c-4302-47f8-be88-ac49b3f71235.png&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;由于文档弹道偏左，考虑在控制台里把它水平居中。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; body &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.body;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;body.style.maxWidth &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;800px&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;body.style.marginLeft &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;auto&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;body.style.marginRight &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;auto&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; elements &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; body.getElementsByTagName(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; i &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt; elements.length; i&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    elements[i].style.maxWidth &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;100%&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    elements[i].style.boxSizing &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;border-box&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;lab内容简单介绍&#34;&gt;lab内容简单介绍&lt;/h1&gt;&#xA;&lt;p&gt;lab1是比较独立的开胃小菜，要实现一个Google曾经使用的MapReduce框架。&lt;/p&gt;&#xA;&lt;p&gt;lab2实现一个简单的单体KV服务器，要求在网络不稳定的情况下也能保证服务不出错。&lt;/p&gt;&#xA;&lt;p&gt;lab3则是实现Raft协议。&lt;/p&gt;&#xA;&lt;p&gt;lab4要基于lab3实现的Raft协议，构建一个KV服务器集群，也就是在lab2的基础上用Raft协议保证Fault-tolerant。&lt;/p&gt;&#xA;&lt;p&gt;lab5则要在lab4的基础上，把数据库的数据分为几个分片（shard）来减轻单个服务器负担，需要实现他们的数据迁移。&lt;/p&gt;&#xA;&lt;p&gt;个人认为最难实现的两个lab显然是lab3和lab5。lab3需要对Raft的原始论文仔细研读，lab5则需要一开始就设计好整个架构如何实现，辅以网上搜索相关的实现思路才好开始上手。&lt;/p&gt;&#xA;&lt;h1 id=&#34;debug小技巧&#34;&gt;Debug小技巧&lt;/h1&gt;&#xA;&lt;p&gt;个人认为实现这些lab最有挑战性的地方不是在设计或者编写上，而是debug上。因为传统的打断点debug方法是对一个单体应用操作，而本次lab需要面对的是一个集群系统，打断点的方法就很难操作，所以主要还是靠print大法。那么设计一个好的打印函数非常有必要，例如可以把打印函数抽象出来。例如lab5我用了这样一个函数对println包装&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;SSPrintf&lt;/span&gt;(format &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, a &lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt;{}) (n &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, err &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; SDebug {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;log.&lt;span style=&#34;color:#50fa7b&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[server %d]&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt;format, &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;([]&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt;{}{kv.gid}, a&lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;)&lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;kv.gid是标识ShardKV的相关信息之一，实践上还可以塞入更多的基本信息，当然这可能要考虑获取这些信息会不会造成读写上的条件竞争的问题。&lt;/p&gt;&#xA;&lt;p&gt;本次实验我只用了SDebug来判断是否打印日志，但实际上可以设计一个类似level的东西，来方便区分重要日志和不那么重要的日志。&lt;/p&gt;&#xA;&lt;p&gt;在需要分析Bug日志的时候，可以借助Linux的tee命令让日志同时输出到stdout和文件里。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;test&lt;/span&gt; -race -run TestConcurrent3_5B | tee bug.txt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在需要输出日志的地方可以多加几个条件判断，确认是bug可能发生的那种条件，这样可以减少大量无意义的日志。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MIT 6.5840(2) - Lab1 MapReduce</title>
      <link>https://blog.kingbridge.one/posts/2024_fall/mit-6.58402/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.kingbridge.one/posts/2024_fall/mit-6.58402/</guid>
      <description>&lt;h1 id=&#34;理论&#34;&gt;理论&lt;/h1&gt;&#xA;&lt;p&gt;MapReduce主要用来解决大规模数据处理的问题，它能够将一个计算任务分解为许多小任务，这些小任务可以在多台机器上并行执行，从而大大提高处理速度和效率。&lt;/p&gt;&#xA;&lt;p&gt;它的核心思想参考Google论文中的图片&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;&#xD;&#xA;        /posts/2024_fall/assets/1720323199815-9184d63b-4736-412e-bc32-1487718c2c04.png&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Master程序是主要的程序，它会将文件（N个）分配个worker，所有worker是对等的。worker将会首先执行Map命令，接受一些文件，然后输出为键值对并写入R个（用户可以自定义R的值）中间文件（图中的Intermediate files）。&lt;strong&gt;当所有Map任务完成后&lt;/strong&gt;，Master会给worker分配Reduce任务，对中间文件进行处理，然后生成最终的结果文件。&lt;/p&gt;&#xA;&lt;p&gt;其中，Map函数和Reduce函数可以以插件的形式提供给系统。&lt;/p&gt;&#xA;&lt;p&gt;例如，在Words Count场景下（统计若干文件里每个相同单词的数量）：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;map(String key, String value):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    // key: document name&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    // value: document contents&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    for each word w in value:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        EmitIntermediate(w, &amp;#34;1&amp;#34;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;reduce(String key, Iterator values):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    // key: a word&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    // values: a list of counts&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    int result = 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    for each v in values:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result += ParseInt(v);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Emit(AsString(result));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个例子中，map函数将生成一系列key为word，value为&amp;quot;1&amp;quot;的中间文件，然后reduce将同一个key聚合，统计value的数量。&lt;/p&gt;&#xA;&lt;p&gt;这样我们就实现了数据集的分布式处理。&lt;/p&gt;&#xA;&lt;h1 id=&#34;代码&#34;&gt;代码&lt;/h1&gt;&#xA;&lt;p&gt;系统的启动流程如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>MIT 6.5840(3) - Lab3 Raft</title>
      <link>https://blog.kingbridge.one/posts/2024_fall/mit-6.58403/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.kingbridge.one/posts/2024_fall/mit-6.58403/</guid>
      <description>&lt;p&gt;由于Lab2是一个KV数据库，和Lab3、Lab4比较相关，所以之后的文章会把他们放在一起。这篇文章先介绍Lab3。&lt;/p&gt;&#xA;&lt;h1 id=&#34;raft算法概览资料&#34;&gt;Raft算法概览资料&lt;/h1&gt;&#xA;&lt;p&gt;可以去这个网站可视化地理解Raft算法&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://thesecretlivesofdata.com/raft/#home&#34;&gt;Raft (thesecretlivesofdata.com)&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;算法实现的所有细节在raft-extended论文中都有清晰的阐述，这里不再赘述。重点关注figure 2的实现逻辑&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf&#34;&gt;pdos.csail.mit.edu/6.824/papers/raft-extended.pdf&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;3a-leader-election&#34;&gt;3A: Leader Election&lt;/h1&gt;&#xA;&lt;p&gt;为了实现Leader Election，事实上我们就要实现Raft中最核心的两个timing了。我把ElectionTimeout和broadcastTime分别用electionTickerHandler和broadcastTickerHandler封装，他们用Ticker来控制（尽管课程建议不要用Ticker，但其实也不难实现）&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;Ticker&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;killed&lt;/span&gt;() &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;rf.electionTimer.C:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;electionTickerHandler&lt;/span&gt;()&lt;span style=&#34;color:#6272a4&#34;&gt;// 这个函数会reset timer，下同&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&#x9;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;rf.broadcastTimer.C:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;broadcastTickerHandler&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// reset timer&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;resetElectionTimeout&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#50fa7b&#34;&gt;resetTimer&lt;/span&gt;(rf.electionTimer, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getElectionTimeout&lt;/span&gt;())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;resetBroadcastTimeout&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#50fa7b&#34;&gt;resetTimer&lt;/span&gt;(rf.broadcastTimer, time.&lt;span style=&#34;color:#50fa7b&#34;&gt;Duration&lt;/span&gt;(broadcastTimeout)&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;time.Millisecond)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;resetTimer&lt;/span&gt;(timer &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;time.Timer, d time.Duration) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !timer.&lt;span style=&#34;color:#50fa7b&#34;&gt;Stop&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;timer.C:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;default&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;timer.&lt;span style=&#34;color:#50fa7b&#34;&gt;Reset&lt;/span&gt;(d)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 初始化：&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;rf.electionTimer = time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTimer&lt;/span&gt;(rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getElectionTimeout&lt;/span&gt;())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rf.broadcastTimer = time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTimer&lt;/span&gt;(time.&lt;span style=&#34;color:#50fa7b&#34;&gt;Duration&lt;/span&gt;(broadcastTimeout) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; time.Millisecond)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;electionTickerHandler根据当前state的状态决定是否要发起竞选&lt;/p&gt;</description>
    </item>
    <item>
      <title>MIT 6.5840(4) - Lab2 &amp; Lab4</title>
      <link>https://blog.kingbridge.one/posts/2024_fall/mit-6.58404/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.kingbridge.one/posts/2024_fall/mit-6.58404/</guid>
      <description>&lt;h1 id=&#34;lab2-keyvalue-server&#34;&gt;Lab2 Key/Value Server&lt;/h1&gt;&#xA;&lt;p&gt;lab2要求实现一个线性一致的KV数据库，可能会存在不稳定的网络（比如高延迟、丢包等情况），但是server不会crash。&lt;/p&gt;&#xA;&lt;p&gt;难点在于client由于超时重传（类似于TCP），可能会发送一个请求多次，server接收到的这些重复请求也不一定是连续的。此时就需要server维护一个hashMap用于记录请求ID以及对应的第一次成功的返回结果。&#xA;hashSet显然需要及时清理。我采用的方案是client在确认发包成功后，继续发送携带请求ID的ResolveRPC直到成功，server通过ResovleRPC把hashMap中的请求ID删除。删除操作是幂等的，不需要保证线性一致。&#xA;例如，一个完整的PUT请求如下：&lt;/p&gt;&#xA;&lt;p&gt;server维护done = make(map[int64]string)&lt;/p&gt;&#xA;&lt;p&gt;● client发送PUT(x,1)，ID=1&lt;/p&gt;&#xA;&lt;p&gt;● server判断ID是否存在于done。如果存在，返回里面的值；否则处理并把结果存在done里&lt;/p&gt;&#xA;&lt;p&gt;● client收到之后发送Resolve(1)&lt;/p&gt;&#xA;&lt;p&gt;● server执行delete(done, 1)&lt;/p&gt;&#xA;&lt;p&gt;一次上述的操作是原子性的。&lt;/p&gt;&#xA;&lt;h1 id=&#34;lab4-fault-tolerant-kvserver&#34;&gt;Lab4 Fault-tolerant KVServer&lt;/h1&gt;&#xA;&lt;p&gt;基于RAFT协议实现一个Fault-tolerant KVServer&lt;/p&gt;&#xA;&lt;h2 id=&#34;client实现&#34;&gt;Client实现&lt;/h2&gt;&#xA;&lt;p&gt;所有的读写请求都必须直接从client发送给leader server。有两种情况client不知道leader是谁：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一次发送请求&lt;/li&gt;&#xA;&lt;li&gt;server易主/crash，返回报错&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;此时client就需要不断重新尝试另一个server，直到请求被成功接收。注意到不同的命令有相同的发送方式，可以抽象出一层来专门用于发送RPC，我这里使用了策略模式。&lt;/p&gt;&#xA;&lt;h2 id=&#34;server实现&#34;&gt;Server实现&lt;/h2&gt;&#xA;&lt;h3 id=&#34;如何返回rpc结果&#34;&gt;如何返回RPC结果&lt;/h3&gt;&#xA;&lt;p&gt;对于RPC接受的一个Op，leader需要将它通过Raft的Start接口达成共识。对于写请求（GET），client只需要知道它成功就行；对于读请求（PUT/APPEND），client还需要知道结果。&lt;/p&gt;&#xA;&lt;p&gt;我们用一个专门的协程applier循环读取Raft commit上来的Op。如果是读请求，不做处理；如果是写请求，则更新KVmap。这样每一个Op都对应着一个独立的commandIndex，定义一个这样的map：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;resultChMap &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; opResult&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;RPC协程与applier协程通过这个map里的管道通信，以返回RPC结果。&lt;/p&gt;&#xA;&lt;p&gt;要注意RPC在返回结果后需要销毁对应的通道。&lt;/p&gt;&#xA;&lt;h3 id=&#34;幂等性设计&#34;&gt;幂等性设计&lt;/h3&gt;&#xA;&lt;h4 id=&#34;raft层commitindex幂等&#34;&gt;raft层commitIndex幂等&lt;/h4&gt;&#xA;&lt;p&gt;raft有可能提交log过时的commitIndex，因此要注意在真正apply的时候添加如下判断&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; msg.CommandIndex &amp;gt; kv.lastApplied&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但这样可能会造成过时请求得不到channel的信息而发生阻塞，所以还需要在RPC处添加timeout。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ticker &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTicker&lt;/span&gt;(time.&lt;span style=&#34;color:#50fa7b&#34;&gt;Duration&lt;/span&gt;(CHANNEL_TIMEOUT) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; time.Millisecond)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; ticker.&lt;span style=&#34;color:#50fa7b&#34;&gt;Stop&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; opResult &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;ch:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; opResult.err &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        reply.Err = &lt;span style=&#34;color:#50fa7b&#34;&gt;Err&lt;/span&gt;(opResult.err)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;ticker.C:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    reply.Err = NOTALEADER&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;client请求幂等&#34;&gt;client请求幂等&lt;/h4&gt;&#xA;&lt;p&gt;由于网络故障等原因，server接收到的命令可能是重复的，并且client只认最新结果（这和TCP超时重传有所差异）。对于读请求，并不会使得KVmap状态发生改变；但是对于写请求，就必须保证它的幂等性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MIT 6.5840(5) - Lab5 Sharded KeyValue Service</title>
      <link>https://blog.kingbridge.one/posts/2024_fall/mit-6.58405/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.kingbridge.one/posts/2024_fall/mit-6.58405/</guid>
      <description>&lt;h2 id=&#34;font-stylecolorrgb0-0-0架构总览font&#34;&gt;&lt;!-- raw HTML omitted --&gt;架构总览&lt;!-- raw HTML omitted --&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Lab5在KVRaft的基础上实现了数据的分布式存储，把全量数据分成一个个&amp;quot;Shard&amp;quot;，分别存储在不同的Group里，每个Group是一群Raft集群，这些Group里的服务器可以通过外部API实时调整他们的加入、退出。&lt;/p&gt;&#xA;&lt;p&gt;下面这张图描述了ShardKV的架构&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;&#xD;&#xA;        /posts/2024_fall/assets/1730270544444-d1c43a0e-510d-4208-ac45-4ac8184a4497-1730303201535-3-1730303541114-3.png&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;一些补充：&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个Group之间唯一的通信是Shard Migration，和Raft无关，而一个Group的内部几个Server形成一个Raft集群&lt;/li&gt;&#xA;&lt;li&gt;Group N里的KVServer 1是当前Group的raft leader，其余是follower。当Client请求KVServer的时候，会像KVRaft那样遍历这些KVServer，直到找到Leader&lt;/li&gt;&#xA;&lt;li&gt;Config的定义如下：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Config &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Num    &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;              &lt;span style=&#34;color:#6272a4&#34;&gt;// config number&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    Shards [NShards]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;     &lt;span style=&#34;color:#6272a4&#34;&gt;// shardId -&amp;gt; gid&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    Groups &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;][]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// gid -&amp;gt; servers[]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&amp;ldquo;Shard&amp;rdquo;，是由Key唯一确定的，课程代码里给的转换方式是：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;key2shard&lt;/span&gt;(key &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(key) &amp;gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;shard = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;int&lt;/span&gt;(key[&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;shard &lt;span style=&#34;color:#ff79c6&#34;&gt;%=&lt;/span&gt; shardctrler.NShards&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; shard&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;5a-shardctrler&#34;&gt;5A shardctrler&lt;/h2&gt;&#xA;&lt;p&gt;需要实现这几个接口：Join/Leave/Move/Query。&lt;/p&gt;</description>
    </item>
    <item>
      <title>利用Github Actions生成CodeQL数据库</title>
      <link>https://blog.kingbridge.one/posts/2024_fall/git-actions-codeql/</link>
      <pubDate>Thu, 28 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.kingbridge.one/posts/2024_fall/git-actions-codeql/</guid>
      <description>&lt;p&gt;&lt;strong&gt;利用Github Actions生成CodeQL数据库 &amp;ndash; 以AliyunCTF2024 Chain17的反序列化链挖掘为例&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.blog/2022-08-15-the-next-step-for-lgtm-com-github-code-scanning/&#34;&gt;lgtm&lt;/a&gt;社区在2022年关闭后，CodeQL只能在本地手动构建，lgtm则被整合进了&lt;a href=&#34;https://docs.github.com/en/code-security/code-scanning/introduction-to-code-scanning/about-code-scanning&#34;&gt;Github Code Scanning&lt;/a&gt;中。&lt;/p&gt;&#xA;&lt;p&gt;可以在Github Action中使用&lt;code&gt;github/codeql-action&lt;/code&gt;来用官方提供的queries对repository的代码进行扫描，结果会显示为Code Scanning Alerts。官方文档还提到，可以自定义QL语句。但是鄙人根据官方文档的配置尝试多次后并不认为可以自定义queries（（&lt;/p&gt;&#xA;&lt;p&gt;但是，可以结合&lt;code&gt;actions/upload-artifact&lt;/code&gt;这个action将构建好的CodeQL数据库导出，然后在本地导入，本地查询。&lt;/p&gt;&#xA;&lt;p&gt;而CodeQL数据库的生成需要正确的编译。幸运的是，github code scanning为我们提供了自动识别编译脚本的功能。&lt;/p&gt;&#xA;&lt;p&gt;另外，Public repository的Actions是免费的，Private repository有免费额度。实战中我们fork官方的repository即可。&lt;/p&gt;&#xA;&lt;h1 id=&#34;题目背景&#34;&gt;题目背景&lt;/h1&gt;&#xA;&lt;p&gt;题目为两个部分，agent和server，都是old-fashion的反序列化入口。题目的流程不再赘述，可以移步&lt;a href=&#34;https://xz.aliyun.com/t/14190&#34;&gt;官方WP&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里说一下思路&lt;/p&gt;&#xA;&lt;h2 id=&#34;agent&#34;&gt;agent&lt;/h2&gt;&#xA;&lt;p&gt;已知&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Hessian反序列化Map的时候会调用Map.put&lt;/li&gt;&#xA;&lt;li&gt;cn.hutool.json.JSONObject#put(&amp;ldquo;foo&amp;rdquo;, AtomicReference) -&amp;gt; AtomicReference#toString，注意AtomicReference是JDK的内部类才能调用toString，否则会根据属性调用getter&lt;/li&gt;&#xA;&lt;li&gt;POJONode.toString -&amp;gt; Bean.getObject&lt;/li&gt;&#xA;&lt;li&gt;Bean.getObject返回object后，jackson会调用object的所有getter（根据getter名字）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;所以就需要找一条getter2RCE的链子并绕过黑名单。给了h2依赖，容易想到&lt;a href=&#34;https://su18.org/post/jdbc-connection-url-attack/#h2-rce&#34;&gt;JDBC Connection URL Attack | 素十八 (su18.org)&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;也就是需要寻找hutool库中getter -&amp;gt; DriverManager.getConnection的链子&lt;/p&gt;&#xA;&lt;h2 id=&#34;server&#34;&gt;server&lt;/h2&gt;&#xA;&lt;p&gt;已知&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;XString#toString -&amp;gt; POJONode#toString -&amp;gt; getter&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;需要找jOOQ库中getter -&amp;gt; RCE的链子&lt;/p&gt;&#xA;&lt;h1 id=&#34;hacking-with-github-actions&#34;&gt;Hacking With Github Actions&lt;/h1&gt;&#xA;&lt;h2 id=&#34;agent-1&#34;&gt;agent&lt;/h2&gt;&#xA;&lt;h3 id=&#34;云编译&#34;&gt;云编译&lt;/h3&gt;&#xA;&lt;p&gt;fork仓库&lt;a href=&#34;https://github.com/dromara/hutool&#34;&gt;dromara/hutool: 🍬A set of tools that keep Java sweet. (github.com)&lt;/a&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
